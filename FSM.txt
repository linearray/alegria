mental notes for new multi-row store:

key | sequencenumber | state | ended | transition | value
----+----------------+-------+-------+------------+------
A     1                init    false   null         {"account_balance" = 0}
A     2                active  false   "pymt recvd" {"account_balance" = 100}
A     3                active  false   "pymt recvd" {"account_balance" = 150}

as MsgID use incrementing integer in combination with the UUID of the FSM?
state should be an arbitrary object, as long as it can be encoded?

key takeaways:
recover thread "recovers" all step1 messages that are older than Timeout seconds


TODO:
* Make the type of the key variable.
* MemoryStore is useless at the moment, because update does not execute effects
* Provide an event sourcing backend.
* put WAL with store (optionally?)
* Ideally we could force Transitions to be a total function, e.g. by introducing an error state
  that all invalid transitions go to.
** Does SafeHaskell help?
* Can we get rid of "dead" txs in recoverAll?
** Explore whether we can run openTxn and patchPhase1 in the same transaction. This is particularly attractive if we store the WAL
** together with the FSM Instance.
* Do a -Wall run
